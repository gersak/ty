#!/usr/bin/env node
/**
 * Lucide Icons Generator for TypeScript
 * Generates TypeScript icon files from Lucide icon repository
 * 
 * Similar to: gen/ty/generate/lucide.clj
 * Each icon is a separate constant for perfect tree-shaking!
 */

import { execSync } from 'child_process'
import { makeSafeIdentifier } from './reserved-words.mjs'
import { existsSync, mkdirSync, readdirSync, readFileSync, writeFileSync, rmSync } from 'fs'
import { join, basename } from 'path'

const ROOT = '.icons'
const REPO_URL = 'https://github.com/lucide-icons/lucide.git'
const REPO_PATH = join(ROOT, 'lucide')
const ICONS_PATH = join(REPO_PATH, 'icons')
const OUTPUT_PATH = 'src/icons/lucide.ts'

/**
 * Ensure root directory exists
 */
function ensureRoot() {
  if (!existsSync(ROOT)) {
    mkdirSync(ROOT, { recursive: true })
  }
}

/**
 * Clone the Lucide repository
 */
function cloneRepo() {
  console.log('üì¶ Cloning Lucide repository...')
  try {
    execSync(`git clone --depth 1 ${REPO_URL} ${REPO_PATH}`, { stdio: 'inherit' })
    console.log('‚úÖ Repository cloned')
  } catch (error) {
    console.error('‚ùå Failed to clone repository:', error.message)
    process.exit(1)
  }
}

/**
 * Clean up cloned repository
 */
function cleanRepo() {
  if (existsSync(REPO_PATH)) {
    console.log('üßπ Cleaning up repository...')
    rmSync(REPO_PATH, { recursive: true, force: true })
    console.log('‚úÖ Repository cleaned')
  }
}

/**
 * List all SVG files in the icons directory
 */
function listIcons() {
  if (!existsSync(ICONS_PATH)) {
    console.error('‚ùå Icons directory not found:', ICONS_PATH)
    return []
  }

  return readdirSync(ICONS_PATH)
    .filter(file => file.endsWith('.svg'))
    .map(file => join(ICONS_PATH, file))
}

/**
 * Read icon metadata from JSON file
 */
function readIconMetadata(svgPath) {
  const jsonPath = svgPath.replace(/\.svg$/, '.json')

  if (!existsSync(jsonPath)) {
    return null
  }

  try {
    const content = readFileSync(jsonPath, 'utf-8')
    return JSON.parse(content)
  } catch (error) {
    console.warn(`‚ö†Ô∏è  Failed to read metadata for ${basename(svgPath)}:`, error.message)
    return null
  }
}

/**
 * Convert kebab-case to camelCase
 */
function toCamelCase(str) {
  return str.replace(/-([a-z0-9])/g, (_, letter) => letter.toUpperCase())
}

/**
 * Convert icon name to valid TypeScript identifier
 * Handles: numbers, special chars, reserved words
 */
function toValidIdentifier(name) {
  // Remove .svg extension
  name = name.replace(/\.svg$/, '')

  // Replace invalid characters (keep letters, numbers, hyphens)
  // This fixes issues like "arrow-down-0-1" 
  name = name.replace(/[^a-zA-Z0-9-]/g, '-')

  // Remove consecutive hyphens
  name = name.replace(/-+/g, '-')

  // Remove leading/trailing hyphens
  name = name.replace(/^-+|-+$/g, '')

  // If starts with number, prefix with 'icon'
  if (/^\d/.test(name)) {
    name = 'icon-' + name
  }

  // Convert to camelCase
  const identifier = toCamelCase(name)

  // Make safe by avoiding JS reserved words
  return makeSafeIdentifier(identifier)
}

/**
 * Process a single SVG file
 */
function processSvg(path) {
  const svgContent = readFileSync(path, 'utf-8')
  const fileName = basename(path)
  const iconName = fileName.replace(/\.svg$/, '')
  const identifier = toValidIdentifier(iconName)
  const metadata = readIconMetadata(path)

  // Clean SVG content (remove XML declaration, trim)
  const cleanedSvg = svgContent
    .replace(/<\?xml[^>]*\?>/g, '')
    .trim()

  // Escape backticks and ${} in SVG
  const escapedSvg = cleanedSvg
    .replace(/\\/g, '\\\\')  // Escape backslashes first
    .replace(/`/g, '\\`')
    .replace(/\$/g, '\\$')

  return {
    identifier,
    iconName,
    svg: escapedSvg,
    metadata,
    aliases: metadata?.aliases?.map(a => ({
      name: a.name,
      identifier: toValidIdentifier(a.name)
    })) || []
  }
}

/**
 * Generate TypeScript icon file with proper tree-shaking
 * Each icon is a separate const (like ClojureScript def)
 */
function generateTypeScript(icons) {
  const lines = [
    '/**',
    ' * Lucide Icons - Auto-generated',
    ' * DO NOT EDIT THIS FILE MANUALLY',
    ' * Generated from: https://github.com/lucide-icons/lucide',
    ` * Total icons: ${icons.length}`,
    ' *',
    ' * Each icon is a separate constant for perfect tree-shaking.',
    ' * Import only what you need:',
    ' *   import { check, heart, star } from \'./lucide.js\'',
    ' */',
    ''
  ]

  // Keep track of used identifiers to avoid duplicates
  const usedIdentifiers = new Set()
  const skippedIcons = []

  // Generate individual icon constants (like ClojureScript defs)
  for (const icon of icons) {
    // Skip if identifier already used (handles duplicate names)
    if (usedIdentifiers.has(icon.identifier)) {
      skippedIcons.push(icon.iconName)
      console.warn(`‚ö†Ô∏è  Skipping duplicate identifier: ${icon.identifier} (${icon.iconName})`)
      continue
    }

    usedIdentifiers.add(icon.identifier)

    // Add comment with metadata
    if (icon.metadata?.tags?.length) {
      lines.push(`// ${icon.iconName} - ${icon.metadata.tags.join(', ')}`)
    }

    // Main icon constant
    lines.push(`export const ${icon.identifier} = \`${icon.svg}\``)
    lines.push('')

    // Alias constants (reference the main constant)
    for (const alias of icon.aliases) {
      // Skip if alias identifier already used
      if (usedIdentifiers.has(alias.identifier)) {
        console.warn(`‚ö†Ô∏è  Skipping duplicate alias: ${alias.identifier} (${alias.name})`)
        continue
      }

      usedIdentifiers.add(alias.identifier)
      lines.push(`// Alias: ${alias.name} ‚Üí ${icon.iconName}`)
      lines.push(`export const ${alias.identifier} = ${icon.identifier}`)
      lines.push('')
    }
  }

  // Add convenience registry object (OPTIONAL, references individual constants)
  lines.push('')
  lines.push('/**')
  lines.push(' * Icon registry object - OPTIONAL')
  lines.push(' * Only import this if you need all icons at once.')
  lines.push(' * For tree-shaking, import individual icons instead.')
  lines.push(' */')
  lines.push('export const lucideIcons: Record<string, string> = {')

  for (const icon of icons) {
    // Skip duplicates
    if (!usedIdentifiers.has(icon.identifier)) continue

    lines.push(`  '${icon.iconName}': ${icon.identifier},`)

    // Add aliases to registry
    for (const alias of icon.aliases) {
      if (!usedIdentifiers.has(alias.identifier)) continue
      lines.push(`  '${alias.name}': ${alias.identifier},`)
    }
  }

  lines.push('}')
  lines.push('')

  // Add metadata
  lines.push('/** Total number of unique icons */')
  lines.push(`export const ICON_COUNT = ${usedIdentifiers.size}`)
  lines.push('')
  lines.push('/** All icon names (including aliases) */')
  lines.push(`export const ICON_NAMES = Object.keys(lucideIcons)`)

  // Report skipped icons
  if (skippedIcons.length > 0) {
    console.log(`\n‚ö†Ô∏è  Skipped ${skippedIcons.length} duplicate icons:`)
    console.log(`   ${skippedIcons.slice(0, 10).join(', ')}${skippedIcons.length > 10 ? '...' : ''}`)
  }

  return lines.join('\n')
}

/**
 * Generate icon statistics
 */
function generateStats(icons) {
  const totalIcons = icons.length
  const totalAliases = icons.reduce((sum, icon) => sum + icon.aliases.length, 0)
  const categories = new Set()
  const tags = new Set()

  icons.forEach(icon => {
    icon.metadata?.categories?.forEach(c => categories.add(c))
    icon.metadata?.tags?.forEach(t => tags.add(t))
  })

  return {
    totalIcons,
    totalAliases,
    totalNames: totalIcons + totalAliases,
    categories: Array.from(categories).sort(),
    tags: Array.from(tags).sort(),
    categoryCount: categories.size,
    tagCount: tags.size
  }
}

/**
 * Main generation function
 */
function generate() {
  console.log('üé® Lucide Icons Generator for TypeScript')
  console.log('==========================================\n')

  // Ensure directories exist
  ensureRoot()

  // Clone repository if needed
  if (!existsSync(REPO_PATH)) {
    cloneRepo()
  } else {
    console.log('üìÅ Using existing repository')
  }

  // List all icons
  console.log('\nüìã Listing icons...')
  const iconPaths = listIcons()
  console.log(`‚úÖ Found ${iconPaths.length} icons`)

  if (iconPaths.length === 0) {
    console.error('‚ùå No icons found!')
    process.exit(1)
  }

  // Process all icons
  console.log('\n‚öôÔ∏è  Processing icons...')
  const icons = iconPaths.map(processSvg)
  console.log(`‚úÖ Processed ${icons.length} icons`)

  // Generate statistics
  const stats = generateStats(icons)
  console.log('\nüìä Statistics:')
  console.log(`   Icons: ${stats.totalIcons}`)
  console.log(`   Aliases: ${stats.totalAliases}`)
  console.log(`   Total names: ${stats.totalNames}`)
  console.log(`   Categories: ${stats.categoryCount}`)
  console.log(`   Tags: ${stats.tagCount}`)

  // Generate TypeScript file
  console.log('\nüìù Generating TypeScript file...')
  const tsContent = generateTypeScript(icons)

  // Ensure output directory exists
  const outputDir = join(OUTPUT_PATH, '..')
  if (!existsSync(outputDir)) {
    mkdirSync(outputDir, { recursive: true })
  }

  // Write output file
  writeFileSync(OUTPUT_PATH, tsContent, 'utf-8')
  console.log(`‚úÖ Generated ${OUTPUT_PATH}`)

  // Get file size
  const fileSize = (tsContent.length / 1024).toFixed(2)
  console.log(`   File size: ${fileSize} KB`)

  // Clean up repository
  console.log('\nüßπ Cleaning up...')
  cleanRepo()

  console.log('\n‚úÖ Generation complete!')
  console.log('\nüí° Tree-shaking friendly:')
  console.log('   import { check, heart, star } from \'./ts/icons/lucide.js\'')
  console.log('   // Only these 3 icons will be bundled!')
  console.log('\nüí° Import all (not recommended):')
  console.log('   import { lucideIcons } from \'./ts/icons/lucide.js\'')
  console.log('   // All icons will be bundled (~2-3 MB)')
}

// Run generator
try {
  generate()
} catch (error) {
  console.error('\n‚ùå Generation failed:', error)
  process.exit(1)
}
